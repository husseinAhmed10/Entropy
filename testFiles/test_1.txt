Huffman encoding is a method of compressing strings. The key idea is to replace each character in the string by a sequence of bits in such a way that characters occurring more frequently have a shorter bit representation than characters occurring less frequently. This usually saves space compared to an encoding where all characters are represented by bit sequences of equal length as, for example, in the standard ASCII encoding. For this, we have to compute the frequencies of all characters and then to organise that information in a binary tree. The tree can then be used for both the encoding and the decoding of the input string. We are going to derive a simplistic Maple implementation of the functions needed to encode and to decode strings using Huffman method. It will provide an example of how custom data structures, in this case binary trees, can be represented and used in Maple. We start with the computation of the frequency list. Maple does provide the CharacterFrequencies function in the StringTools package for this. The next step is to turn the frequency sequence into a Huffman tree. Although it is possible to represent trees in Maple by simply using nested lists, we will implement a more advanced method. This will be both more readable and less error prone. Maple does not have a formal data type declaration and in fact, we could use the expressions just without further preparations. However, we decide to enable type checking for our trees. This way, we can later easily check whether something is a leaf or node. Also, we can use the types in the argument lists of procedures in order to guard ourselves against wrong input. The idea is to base the bit representation of the letters on the paths from the root of the Huffman tree to the leaf containing the letter. This will automatically ensure that high frequency letters have shorter codes since they are closer to the root. We agree that going to a left child should be represented by a Zero and that going to right child should be One. In the example tree, for instance, in order to reach a, we have to go left three times. Therefor, the code for a would be three zeros. Similarly, e is left two times and then right such that the code is zero zero one. 